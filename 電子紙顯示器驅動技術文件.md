# QYEG0579RYS683 電子紙顯示器驅動技術文件

## 概述

本文件詳細說明 QYEG0579RYS683 電子紙顯示器的驅動程式架構與實作方法。這是一個針對樹莓派開發的 C++ 驅動程式，支援四色顯示（黑、白、黃、紅）以及多方向顯示模式。

## 硬體規格與連接

### 顯示器規格
- **型號**: QYEG0579RYS683
- **解析度**: 400×272 像素
- **色彩支援**: 4色（2bit），支援黑色、白色、黃色、紅色
- **顯示技術**: 電泳式電子紙技術
- **刷新特性**: 具有記憶功能，斷電後圖像保持不變

### GPIO 腳位連接對應表

| 電子紙腳位 | 功能 | 樹莓派實體腳位 | BCM 編號 | 說明 |
|-----------|------|--------------|----------|------|
| VCC | 電源 | 1 (3.3V) | - | 3.3V電源供應 |
| GND | 接地 | 6 (GND) | - | 公共接地 |
| DIN | 資料輸入 | 19 (MOSI) | 10 | SPI主設備輸出從設備輸入 |
| CLK | 時脈 | 23 (SCLK) | 11 | SPI串列時脈 |
| CS | 晶片選擇 | 24 (CE0) | 8 | SPI晶片選擇訊號 |
| D/C | 資料/命令 | 22 | 25 | 區分資料與命令傳輸 |
| RES | 復位 | 11 | 17 | 硬體復位訊號 |
| BUSY | 忙碌狀態 | 18 | 24 | 顯示器忙碌狀態指示 |

## 軟體架構

### 類別架構圖

```
EpdIf (硬體抽象層)
   ↑ 繼承
Epd (顯示器驅動類別)
   ↑ 使用
main.cpp (應用程式主程式)
```

### 1. EpdIf 類別 - 硬體抽象層

**檔案**: `epdif.h` / `epdif.cpp`

**功能**: 提供底層硬體操作介面，封裝 BCM2835 函式庫的功能。

#### 主要方法:

- **`IfInit()`**: 初始化 BCM2835 函式庫和 SPI 介面
  - 設定 GPIO 腳位模式 (RST_PIN, DC_PIN 為輸出; BUSY_PIN 為輸入)
  - 配置 SPI 參數:
    - 位元順序: MSB 優先 (高位元先傳)
    - SPI 模式: MODE0 (CPOL=0, CPHA=0)
    - 時脈分頻: 128 分頻
    - 晶片選擇: CE0，低電位有效

- **`DigitalWrite(pin, value)`**: GPIO 輸出控制
- **`DigitalRead(pin)`**: GPIO 輸入讀取
- **`SpiTransfer(data)`**: SPI 資料傳輸
- **`DelayMs(time)`**: 毫秒延遲

### 2. Epd 類別 - 主要顯示器驅動

**檔案**: `epd0579RYS683.h` / `epd0579RYS683.cpp`

**功能**: 實作電子紙顯示器的高階控制功能。

#### 顯示方向支援:
- **FPCLeft (1)**: FPC排線朝左
- **FPCRight (2)**: FPC排線朝右
- **FPCUp (3)**: FPC排線朝上
- **FPCDown (4)**: FPC排線朝下

#### 色彩定義 (2位元編碼):
```cpp
#define black   0x00    // 00: 黑色
#define white   0x01    // 01: 白色
#define yellow  0x02    // 10: 黃色
#define red     0x03    // 11: 紅色
```

#### 核心方法詳解:

**1. `Init(Direction)` - 顯示器初始化**

根據 FPC 方向設定不同的 PSR (Panel Setting Register) 參數:

| 方向 | PSR_Master | PSR_Slave | 說明 |
|------|------------|-----------|------|
| FPCLeft | 0x2B | 0x2F | UD=1,SHL=0 / UD=1,SHL=1 |
| FPCRight | 0x27 | 0x23 | UD=0,SHL=1 / UD=0,SHL=0 |
| FPCUp | 0x23 | 0x27 | UD=0,SHL=0 / UD=0,SHL=1 |
| FPCDown | 0x2F | 0x2B | UD=1,SHL=1 / UD=1,SHL=0 |

初始化流程:
1. 硬體復位
2. 配置主/從控制器參數
3. 設定溫度補償、邊框顏色
4. 配置解析度和顯示範圍
5. 設定 HTOTAL 參數

**2. `SendCommand(command)` / `SendData(data)` - 通訊協定**

```cpp
// 傳送命令: D/C=LOW, 然後透過SPI傳送
void SendCommand(command) {
    DigitalWrite(dc_pin, LOW);
    SpiTransfer(command);
}

// 傳送資料: D/C=HIGH, 然後透過SPI傳送
void SendData(data) {
    DigitalWrite(dc_pin, HIGH);
    SpiTransfer(data);
}
```

**3. `WaitUntilIdle()` - 等待顯示器就緒**

監控 BUSY 腳位狀態:
- LOW: 顯示器忙碌中
- HIGH: 顯示器空閒可操作

**4. `Reset()` - 硬體復位**

復位時序:
1. RES 拉低 200ms
2. RES 拉高 200ms
3. 等待顯示器就緒

**5. 圖像資料處理方法**

**`SetFrameScreen_ALL_Horizontal()`** - 水平顯示模式

處理流程:
1. 根據 FPC 方向決定左右控制器分工
2. 將 2bit 色彩資料重新編碼為顯示器格式
3. 分別向左半部和右半部控制器傳送資料

**`SetFrameScreen_ALL_Vertical()`** - 垂直顯示模式

類似水平模式，但控制上下兩個控制器。

**色彩轉換邏輯**:
```cpp
// 每個位元組包含 4 個像素 (2bit×4=8bit)
temp = imageData[position];
data_H1 = Color_get(temp>>6 & 0x03) << 6;  // 第1個像素
data_H2 = Color_get(temp>>4 & 0x03) << 4;  // 第2個像素
data_L1 = Color_get(temp>>2 & 0x03) << 2;  // 第3個像素
data_L2 = Color_get(temp & 0x03);          // 第4個像素
finalData = data_H1 | data_H2 | data_L1 | data_L2;
```

**6. `DisplayFrame_And_Sleep()` - 顯示更新與休眠**

執行流程:
1. 同時啟用主/從控制器 (MS_CTRL = 0x04)
2. 電源開啟 (PON 命令)
3. 等待顯示器完成刷新
4. 關閉電源 (POF 命令)
5. 進入深度休眠 (DSLP 命令)

**7. `ClearFrameMemory()` - 清除顯示記憶體**

將整個顯示區域設定為白色 (0x55)，分別對主/從控制器執行。

### 3. 圖像資料結構

**檔案**: `imagedata.h` / `imagedata.cpp`

包含預編譯的圖像陣列:
- `gImage_1[]`: 示範圖像1
- `gImage_2[]`: 示範圖像2
- `gImage_3[]`: 示範圖像3

圖像格式:
- 每像素 2 位元，4 個像素打包為 1 個位元組
- 總大小: 100×272 位元組 = 27,200 位元組
- 資料排列: 按行優先順序 (row-major order)

### 4. 主程式邏輯

**檔案**: `main.cpp`

示範程式執行流程:
1. **FPC朝左**: 初始化 → 顯示 gImage_1 → 休眠 4 秒
2. **FPC朝右**: 初始化 → 顯示 gImage_2 → 休眠 4 秒
3. **FPC朝下**: 初始化 → 顯示 gImage_3 → 休眠 4 秒
4. **FPC朝上**: 初始化 → 顯示 gImage_3 → 休眠 4 秒
5. **清除顯示**: 初始化 → 清空螢幕 → 無限迴圈

## 控制器命令對照表

| 命令碼 | 縮寫 | 全名 | 功能說明 |
|--------|------|------|----------|
| 0x00 | PSR | Panel Setting Register | 面板設定暫存器，控制掃描方向 |
| 0x01 | PWR | Power Setting | 電源設定 |
| 0x02 | POF | Power OFF | 關閉電源 |
| 0x04 | PON | Power ON | 開啟電源 |
| 0x07 | DSLP | Deep Sleep | 深度休眠模式 |
| 0x10 | DTM | Data Transmission Mode | 資料傳輸模式，開始傳送圖像資料 |
| 0x12 | DRF | Display Refresh | 顯示刷新命令 |
| 0x41 | TSE | Temperature Sensor Enable | 溫度感測器啟用 |
| 0x50 | CDI | VCOM and Data Interval | VCOM與資料間隔設定 |
| 0x61 | TRES | Resolution Setting | 解析度設定 |
| 0x62 | HTOTAL | H Total Setting | 水平總計時間設定 |
| 0x65 | GSST | Gate/Source Start Setting | 閘極/源極起始設定 |
| 0xE0 | CCSET | Cascade Setting | 串聯設定，用於主從模式 |
| 0xEE | MS_CTRL | Master/Slave Control | 主從控制選擇 |

### MS_CTRL 控制值:
- **0x04**: 同時啟用主從控制器
- **0x05**: 僅啟用主控制器 (MASTER)
- **0x06**: 僅啟用從控制器 (SLAVE)

## 建置與執行

### 環境需求:
- **作業系統**: Raspbian (Raspberry Pi OS)
- **硬體**: Raspberry Pi (任意版本)
- **依賴函式庫**: BCM2835 C Library

### 安裝 BCM2835 函式庫:

```bash
# 下載並編譯 BCM2835 函式庫
wget http://www.airspayce.com/mikem/bcm2835/bcm2835-1.xx.tar.gz
tar zxvf bcm2835-1.xx.tar.gz
cd bcm2835-1.xx
./configure
make
sudo make check
sudo make install
```

### 編譯與執行:

```bash
# 編譯專案
make

# 執行示範程式 (需要 root 權限存取 GPIO)
sudo ./epd

# 清理編譯檔案
make clean
```

## 開發注意事項

### 1. 權限需求
- 所有 GPIO 操作需要 root 權限
- 必須使用 `sudo` 執行程式

### 2. 電子紙特性
- **刷新速度慢**: 全螢幕刷新約需 2-4 秒
- **殘影效應**: 快速切換可能產生殘影
- **記憶特性**: 斷電後圖像保持不變
- **壽命限制**: 避免過度頻繁刷新

### 3. 程式設計建議
- **等待機制**: 每次操作後確實等待 BUSY 信號
- **電源管理**: 顯示完成後進入休眠模式節電
- **錯誤處理**: 檢查初始化返回值
- **資料格式**: 確保圖像資料符合 2bit 格式要求

### 4. 除錯技巧
- 使用示波器檢查 SPI 時序
- 監控 GPIO 腳位電位變化
- 檢查硬體連線是否正確
- 確認 BCM2835 函式庫正確安裝

## 擴展開發

### 1. 自訂圖像顯示
- 建立圖像轉換工具，將一般圖檔轉為 2bit 格式
- 實作即時圖像緩衝區操作
- 支援部分區域更新以提升效率

### 2. 字型顯示系統
- 整合字型檔案支援
- 實作文字渲染引擎
- 支援中文字型顯示

### 3. 使用者介面框架
- 開發 GUI 元件函式庫
- 實作按鈕、選單等互動元素
- 整合觸控或按鍵輸入

### 4. 網路功能
- Wi-Fi 連線功能
- Web API 圖像下載
- 遠端控制介面

這份技術文件提供了完整的 QYEG0579RYS683 電子紙顯示器驅動程式的技術細節，從硬體連接到軟體架構都有詳盡的說明，可作為進一步開發和維護的參考依據。